import {Command} from '@oclif/command'

import {Utils} from './utils'
import {Writer} from './writer'

export namespace TSGenerator {
    export function header(
        description: string,
        writer: Writer
      ): void {
      writer.writeLine(`/**
* <auto-generated>
* Code generated by ${description}
* Tool github: https://github.com/microsoft/botbuilder-tools
* Changes may cause incorrect behavior and will be lost if the code is
* regenerated.
* </auto-generated>
*/
import {DateTimeSpec, GeographyV2, IntentData, InstanceData, NumberWithUnits, OrdinalV2} from 'botbuilder-ai';`
        )
    }

    export function intents(app: any, writer: Writer): void {
      writer.writeLine()
      writer.writeLineIndented('export interface _Intents { ')
      writer.increaseIndentation()
      app.intents.forEach((intent: any) => {
        writer.writeLineIndented(`${Utils.normalizeName(intent.name)}: IntentData;`)
      }
        )
      writer.decreaseIndentation()
      writer.writeLine('};')
    }

    export function propertyName(name: any): string {
      return Utils.jsonPropertyName(name)
    }

    export function writeEntity(entity: any, type: string, writer: Writer): void {
      Utils.entityApply(entity, name => {
        let realName = propertyName(name)
        switch (type) {
        case 'age':
        case 'dimension':
        case 'money':
        case 'temperature':
          writer.writeLineIndented(`${realName}?: NumberWithUnits[];`)
          break
        case 'geographyV2':
          writer.writeLineIndented(`${realName}?: GeographyV2[];`)
          break
        case 'ordinalV2':
          writer.writeLineIndented(`${realName}?: OrdinalV2[];`)
          break
        case 'number':
        case 'ordinal':
        case 'percentage':
          writer.writeLineIndented(`${realName}?: number[];`)
          break
        case 'datetimeV2':
          writer.writeLineIndented(`${realName}?: DateTimeSpec[];`)
          break
        case 'list':
          writer.writeLineIndented(`${realName}?: string[][];`)
          break
        default:
          writer.writeLineIndented(`${realName}?: string[];`)
        }
      })
    }

    export function writeEntities(entities: [any], app: any, description: string, writer: Writer): void {
      if (entities.length > 0) {
        writer.writeLine()
        writer.writeLineIndented(`// ${description}`)
        let first = true
        entities.forEach((entity: any) => {
          if (first) {
            first = false
          } else {
            writer.writeLine()
          }
          writeEntity(entity, Utils.isList(entity.name, app) ? 'list' : entity.name, writer)
        })
      }
    }

    export function entities(app: any, writer: Writer): void {
      // Composite instance and data
      if (app.composites !== null && app.composites !== undefined) {
        app.composites.forEach((composite: any) => {
          let name = Utils.normalizeName(composite.name)
          writer.writeLine()
          writer.writeLineIndented(`export interface _Instance${name} {`)
          writer.increaseIndentation()
          composite.children.forEach((child: any) => {
            writer.writeLineIndented(`${propertyName(child)}?: InstanceData[];`)
          }
                )
          writer.decreaseIndentation()
          writer.writeLineIndented('}')
          writer.writeLineIndented(`export interface ${name} {`)
          writer.increaseIndentation()
          composite.children.forEach((child: any) => {
            writeEntity(Utils.entity(child), Utils.isList(child, app) ? 'list' : child, writer)
          }
                )
          writer.writeLineIndented(`$instance?: _Instance${name};`)
          writer.decreaseIndentation()
          writer.writeLineIndented('}')
        }
            )
      }
      writer.writeLine()

      // Entity instance
      writer.writeLineIndented('export interface _Instance {')
      writer.increaseIndentation()
      Utils.writeInstances(app, name => {
        writer.writeLineIndented(`${propertyName(name)}?: InstanceData[];`)
      })
      writer.decreaseIndentation()
      writer.writeLineIndented('}')

      // Entities
      writer.writeLine()
      writer.writeLineIndented('export interface _Entities {')
      writer.increaseIndentation()
      if (app.entities !== null && app.entities !== undefined && app.entities.length > 0) {
        writer.writeLineIndented('// Simple entities')
        app.entities.forEach((entity: any) => {
          writeEntity(entity, entity.name, writer)
          if (entity !== null && entity !== undefined && entity.children !== undefined) {
            // Hierarchical
            entity.children.forEach((child: any) => {
              writeEntity(Utils.entity(child), child, writer)
            }
                    )
          }
        })
      }
      writeEntities(app.prebuiltEntities, app, 'Built-in entities', writer)
      writeEntities(app.closedLists, app, 'Lists', writer)
      writeEntities(app.regex_entities, app, 'Regex entities', writer)
      writeEntities(app.patternAnyEntities, app, 'Pattern.any', writer)

      // Composites
      if (app.composites !== null && app.composites !== undefined && app.composites.Count > 0) {
        writer.writeLine()
        writer.writeLineIndented('// Composites')
        app.composites.forEach((composite: any) => {
          let name = propertyName(composite.name)
          writer.writeLineIndented(`${name}?: ${name}[];`)
        })
      }

      writer.writeLineIndented('$instance : _Instance;')
      writer.decreaseIndentation()
      writer.writeLineIndented('}')
    }

    export function classInterface(className: string, writer: Writer): void {
      writer.writeLine()
      writer.writeLineIndented(`export interface ${className} {`)
      writer.increaseIndentation()
      writer.writeLineIndented('text: string;')
      writer.writeLineIndented('alteredText?: string;')
      writer.writeLineIndented('intents: _Intents;')
      writer.writeLineIndented('entities: _Entities;')
      writer.writeLineIndented('[propName: string]: any;')
      writer.decreaseIndentation()
      writer.writeLineIndented('}')
    }

    export async function generate(description: string, app: any, className: string, outPath: string, command: Command) {
      const outName = `${outPath}/${className}.ts`
      command.log(
            `Generating file ${outName} that contains class ${className}.`
        )
      const writer = new Writer()
      await writer.setOutputStream(outName)
      header(description, writer)
      intents(app, writer)
      entities(app, writer)
      classInterface(className, writer)
      await writer.closeOutputStream()
    }
}
